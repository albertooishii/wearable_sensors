// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// üì° Bluetooth Service - Dream Incubator
// Servicio de bajo nivel para comunicaci√≥n Bluetooth con dispositivos wearables

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart'; // ‚úÖ Para PlatformException
import 'package:flutter_blue_plus/flutter_blue_plus.dart' as fbp;
import 'package:wearable_sensors/src/internal/config/supported_devices_config.dart';
import 'package:wearable_sensors/src/internal/models/bluetooth_connection_state.dart';

import 'package:wearable_sensors/src/internal/models/bluetooth_device.dart';
import 'package:wearable_sensors/src/internal/services/permissions_service.dart';
import 'package:wearable_sensors/wearable_sensors.dart';
import 'package:wearable_sensors/src/internal/utils/ble_uuid_utils.dart';
import 'package:wearable_sensors/src/internal/utils/device_implementation_loader.dart';
import 'package:wearable_sensors/src/internal/vendors/xiaomi/xiaomi_auth_service.dart';

/// Paquete de datos BLE crudos emitido por el BleService
class BleDataPacket {
  const BleDataPacket({
    required this.deviceId,
    required this.serviceUuid,
    required this.characteristicUuid,
    required this.rawData,
    required this.timestamp,
  });

  final String deviceId;
  final String serviceUuid;
  final String characteristicUuid;
  final List<int> rawData;
  final DateTime timestamp;

  @override
  String toString() =>
      'BleDataPacket(device: $deviceId, service: $serviceUuid, char: $characteristicUuid, data: ${rawData.length} bytes)';
}

/// Servicio de bajo nivel para comunicaci√≥n Bluetooth y descubrimiento de dispositivos
class BleService {
  factory BleService() => _instance;
  BleService._internal() {
    // ‚úÖ Xiaomi authentication service initialized lazily per device
    // No need for singleton - cada dispositivo tendr√° su propia instancia

    // üîß Escuchar cambios en el estado de scanning desde flutter_blue_plus
    fbp.FlutterBluePlus.isScanning.listen((final scanning) {
      if (_isScanning != scanning) {
        _isScanning = scanning;
        _updateConnectionState(_connectionState.copyWith(isScanning: scanning));
        debugPrint(
          'üì° Scan state changed: ${scanning ? "SCANNING" : "STOPPED"}',
        );
      }
    });
  }
  static final BleService _instance = BleService._internal();

  // ‚úÖ Xiaomi authentication services (one per device)
  final Map<String, XiaomiAuthService> _xiaomiAuthServices = {};

  // Streams principales (pueden recrearse despu√©s de dispose)
  StreamController<BluetoothConnectionState> _connectionStateController =
      StreamController<BluetoothConnectionState>.broadcast();
  StreamController<BluetoothDevice> _rawBleDeviceController =
      StreamController<BluetoothDevice>.broadcast();
  StreamController<BleDataPacket> _rawBleDataController =
      StreamController<BleDataPacket>.broadcast();

  // Estado interno BLE puro
  final Map<String, StreamSubscription> _connectionStreams = {};

  // üÜï NEW ARCHITECTURE: Device type cache y scanned devices
  final Map<String, String> _deviceTypes = {}; // deviceId ‚Üí deviceType
  final Map<String, BluetoothDevice> _scannedDevices =
      {}; // deviceId ‚Üí BluetoothDevice
  final Map<String, fbp.BluetoothDevice> _connectedDevices =
      {}; // deviceId ‚Üí fbp.BluetoothDevice (cache de instancias)

  // üîß NUEVO: Cache de servicios descubiertos para evitar rediscoverServices en cada write
  final Map<String, List<fbp.BluetoothService>> _discoveredServices =
      {}; // deviceId ‚Üí List<BluetoothService>

  // üîß NUEVO: Tracking de subscriptions de caracter√≠sticas para evitar duplicaci√≥n
  final Map<String, StreamSubscription> _characteristicSubscriptions =
      {}; // "deviceId:characteristicUuid" ‚Üí StreamSubscription

  // Cache para evitar logs repetitivos
  final Set<String> _loggedDevices = <String>{};
  bool _isScanning = false;
  bool _isInitialized = false;
  BluetoothConnectionState _connectionState =
      BluetoothConnectionState.initial();

  // Stream subscription para el scan (para poder cancelarlo)
  StreamSubscription<List<fbp.ScanResult>>? _scanSubscription;

  // Getters p√∫blicos - Solo streams BLE puros
  Stream<BluetoothDevice> get rawBleDevicesStream =>
      _rawBleDeviceController.stream;
  Stream<BleDataPacket> get rawBleDataStream => _rawBleDataController.stream;

  // Getter para acceder al controller desde upper service layer
  StreamController<BleDataPacket> get rawBleDataStreamController =>
      _rawBleDataController;

  // Getter para estado de conexi√≥n
  BluetoothConnectionState get connectionState => _connectionState;
  Stream<BluetoothConnectionState> get connectionStateStream =>
      _connectionStateController.stream;

  /// Recrear StreamControllers si fueron cerrados previamente
  void _recreateControllersIfClosed() {
    if (_rawBleDeviceController.isClosed) {
      debugPrint('üîÑ Recreating closed _rawBleDeviceController');
      _rawBleDeviceController = StreamController<BluetoothDevice>.broadcast();
    }

    if (_connectionStateController.isClosed) {
      debugPrint('üîÑ Recreating closed _connectionStateController');
      _connectionStateController =
          StreamController<BluetoothConnectionState>.broadcast();
    }

    if (_rawBleDataController.isClosed) {
      debugPrint('üîÑ Recreating closed _rawBleDataController');
      _rawBleDataController = StreamController<BleDataPacket>.broadcast();
    }
  }

  /// Inicializar servicio y verificar permisos
  Future<void> initialize() async {
    if (_isInitialized) {
      debugPrint('üîß Disposing BleService...');
      return;
    }

    try {
      // üîÑ Recrear StreamControllers si fueron cerrados anteriormente
      _recreateControllersIfClosed();

      await _checkBluetoothPermissions();
      await _checkBluetoothState();

      // Escuchar cambios en el estado de Bluetooth con flutter_blue_plus
      fbp.FlutterBluePlus.adapterState.listen((final state) {
        _updateConnectionState(
          _connectionState.copyWith(
            isBluetoothEnabled: state == fbp.BluetoothAdapterState.on,
            isBluetoothAvailable:
                state != fbp.BluetoothAdapterState.unavailable,
          ),
        );
      });

      // üîó Escuchar cambios de estado de conexi√≥n autom√°ticos
      // Nota: universal_ble no tiene un callback directo onConnectionChange,
      // pero podemos detectar conexiones autom√°ticas en el m√©todo connectDevice

      // üóëÔ∏è REMOVED: Global UniversalBle.onValueChange callback
      // Ahora usamos characteristic.onValueReceived directamente (API moderna)

      // üóëÔ∏è REMOVED: Loading system devices - upper service layer handles this now

      _isInitialized = true;
      debugPrint('üîµ BleService initialized successfully');
    } on Exception catch (e) {
      debugPrint('‚ùå BleService initialization failed: $e');
      _updateConnectionState(
        _connectionState.copyWith(errorMessage: 'Initialization failed: $e'),
      );
    }
  }

  /// Verificar y solicitar permisos de Bluetooth
  Future<void> _checkBluetoothPermissions() async {
    final allGranted = await PermissionsService.areAllPermissionsGranted();

    if (!allGranted) {
      debugPrint('‚ö†Ô∏è Some Bluetooth permissions missing. Requesting...');
      await PermissionsService.requestBluetoothPermissions();
      // Location permissions removed - not needed on Android 12+ with BLUETOOTH_SCAN neverForLocation flag
    }

    final finalCheck = await PermissionsService.areAllPermissionsGranted();

    _updateConnectionState(
      _connectionState.copyWith(hasPermissions: finalCheck),
    );
  }

  /// Verificar estado de Bluetooth del dispositivo
  Future<void> _checkBluetoothState() async {
    try {
      final adapterState = await fbp.FlutterBluePlus.adapterState.first;
      _updateConnectionState(
        _connectionState.copyWith(
          isBluetoothEnabled: adapterState == fbp.BluetoothAdapterState.on,
          isBluetoothAvailable:
              adapterState != fbp.BluetoothAdapterState.unavailable,
        ),
      );
    } on Exception catch (e) {
      debugPrint('‚ùå Error checking Bluetooth state: $e');
      _updateConnectionState(
        _connectionState.copyWith(
          isBluetoothAvailable: false,
          errorMessage: 'Bluetooth check failed: $e',
        ),
      );
    }
  }

  /// Actualizar estado de conexi√≥n y notificar listeners
  void _updateConnectionState(final BluetoothConnectionState newState) {
    _connectionState = newState;
    _connectionStateController.add(_connectionState);
  }

  /// üÜï Obtener instancia de fbp.BluetoothDevice del cache o crear nueva
  ///
  /// **IMPORTANTE**: Siempre intenta usar instancias REALES del cache primero:
  /// - Devices de bondedDevices (getSystemDevices)
  /// - Devices de scan results (startScanning)
  ///
  /// Solo crea nueva instancia con fromId() como √∫ltimo recurso.
  ///
  /// **IMPORTANTE**: fromId() crea dispositivos SIN NOMBRE, causando "Pair with null" en Android.
  /// Siempre intentar usar dispositivos del scan cache primero.
  ///
  /// **OPTIMIZACI√ìN**: Usa filtrado nativo con withRemoteIds para encontrar dispositivos espec√≠ficos.
  ///
  /// **Parameters:**
  /// - [deviceId]: MAC address del dispositivo
  Future<fbp.BluetoothDevice> getBluetoothDeviceAsync(
    final String deviceId,
  ) async {
    // Paso 1: Verificar cache con servicios descubiertos
    if (_connectedDevices.containsKey(deviceId)) {
      final cachedDevice = _connectedDevices[deviceId]!;
      final hasServices = _discoveredServices.containsKey(deviceId) &&
          _discoveredServices[deviceId]!.isNotEmpty;

      if (hasServices) {
        return cachedDevice; // Cache hit - fast path
      }
      debugPrint('‚ö†Ô∏è Cached device $deviceId has NO services, will rescan');
    }

    // Paso 2: Quick scan con filtrado nativo
    final scannedDevice = await _quickScanForDevice(deviceId);
    if (scannedDevice != null) {
      return scannedDevice;
    }

    // üî¥ FALLBACK: Crear instancia sin nombre (√∫ltimo recurso)
    debugPrint('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Creating device without name for $deviceId');
    debugPrint('   ‚ö†Ô∏è Android will show "Pair with null"');
    debugPrint('   ‚ö†Ô∏è User should scan for device first!');
    final fakeDevice = fbp.BluetoothDevice.fromId(deviceId);
    _connectedDevices[deviceId] = fakeDevice;
    return fakeDevice;
  }

  /// Quick scan con filtrado nativo por MAC address
  Future<fbp.BluetoothDevice?> _quickScanForDevice(
    final String deviceId,
  ) async {
    try {
      // ‚ö†Ô∏è IMPORTANTE: No interrumpir scan principal si est√° activo
      final isScanningNow = await fbp.FlutterBluePlus.isScanning.first;
      if (isScanningNow && _isScanning) {
        debugPrint(
          '‚è∏Ô∏è  Main scan active - skipping quick scan to avoid interruption',
        );
        debugPrint('   üí° Device will be found by main scan');
        return null;
      }

      debugPrint('üîç Quick scan for device with native filter...');

      await fbp.FlutterBluePlus.startScan(
        timeout: const Duration(seconds: 10),
        withRemoteIds: [deviceId], // Filtrado nativo
      );

      final scanResults = await fbp.FlutterBluePlus.scanResults.first;
      await fbp.FlutterBluePlus.stopScan();

      if (scanResults.isNotEmpty) {
        final foundDevice = scanResults.first.device;
        debugPrint('‚úÖ Device found: ${foundDevice.platformName} ($deviceId)');
        _connectedDevices[deviceId] = foundDevice;
        return foundDevice;
      }

      debugPrint('‚ö†Ô∏è Device $deviceId not found after scan');
      return null;
    } on Exception catch (e) {
      debugPrint('‚ö†Ô∏è Quick scan failed: $e');
      return null;
    }
  }

  /// Synchronous version - tries cache and lastScanResults only (no async scan)
  fbp.BluetoothDevice _getBluetoothDevice(final String deviceId) {
    // Intentar obtener del cache (instancia REAL)
    if (_connectedDevices.containsKey(deviceId)) {
      // debugPrint('üéØ Using cached real fbp.BluetoothDevice for $deviceId'); // ‚ö° Commented - cache hits are normal
      return _connectedDevices[deviceId]!;
    }

    // Intentar obtener de scan results (tiene nombre!)
    final scanResults = fbp.FlutterBluePlus.lastScanResults;

    // Usar orElse en vez de try-catch para evitar StateError
    final scannedDevice = scanResults.cast<fbp.ScanResult?>().firstWhere(
          (final result) =>
              result?.device.remoteId.str.toLowerCase() ==
              deviceId.toLowerCase(),
          orElse: () => null,
        );

    if (scannedDevice != null) {
      debugPrint(
        '‚úÖ Found device in scan results: ${scannedDevice.device.platformName} ($deviceId)',
      );
      _connectedDevices[deviceId] = scannedDevice.device;
      return scannedDevice.device;
    }

    // Device not found in scan results
    debugPrint('‚ö†Ô∏è Device $deviceId not found in scan results');

    // üî¥ FALLBACK: Crear nueva instancia usando flutter_blue_plus
    // ‚ö†Ô∏è WARNING: Esto crea un dispositivo SIN NOMBRE ‚Üí "Pair with null" en Android!
    debugPrint(
      '‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Creating NEW fbp.BluetoothDevice.fromId() for $deviceId',
    );
    debugPrint(
      '   ‚ö†Ô∏è This device has NO NAME ‚Üí Android will show "Pair with null"',
    );
    debugPrint('   ‚ö†Ô∏è Recommend scanning first to get device name!');
    final device = fbp.BluetoothDevice.fromId(deviceId);
    _connectedDevices[deviceId] = device; // Guardar en cache
    return device;
  }

  /// Refrescar dispositivos emparejados del sistema
  //  REMOVED: refreshSystemDevices() - upper service layer handles system devices directly

  /// Verificar si un dispositivo est√° en los resultados del escaneo

  /// Verificar si un dispositivo est√° bonded (paired)
  /// Retorna true si est√° bonded, false en caso contrario
  Future<bool> isDeviceBonded(final String deviceId) async {
    try {
      final bleDevice = fbp.BluetoothDevice.fromId(deviceId);
      final bondState = await bleDevice.bondState.first;
      return bondState == fbp.BluetoothBondState.bonded;
    } on Exception catch (e) {
      debugPrint('‚ùå Error checking bond state for $deviceId: $e');
      return false;
    }
  }

  /// Verificar si el adaptador Bluetooth est√° encendido
  /// Retorna true si Bluetooth est√° ON, false en caso contrario

  /// Obtener la lista de dispositivos BLE conectados actualmente
  /// Retorna lista de device IDs (MAC addresses)

  /// Obtener instancia de BluetoothDevice de flutter_blue_plus
  /// SOLO para uso interno de servicios de bajo nivel (xiaomi_auth_service)
  fbp.BluetoothDevice? getFlutterBlueDevice(final String deviceId) {
    return _connectedDevices[deviceId];
  }

  /// ‚úÖ SIMPLE: Crear fbp.BluetoothDevice directamente desde ID
  ///
  /// Wrapper directo de flutter_blue_plus BluetoothDevice.fromId()
  ///
  /// **Par√°metros:**
  /// - [deviceId]: MAC address del dispositivo (ej: 'AA:BB:CC:DD:EE:FF')
  ///
  /// **Retorna:**
  /// - [fbp.BluetoothDevice] instancia lista para usar
  ///
  /// **Uso:**
  /// ```dart
  /// final device = bleService.getBluetoothDevice('AA:BB:CC:DD:EE:FF');
  /// await device.connect();
  /// ```
  fbp.BluetoothDevice getBluetoothDevice(final String deviceId) {
    return fbp.BluetoothDevice.fromId(deviceId);
  }

  /// Detener escaneo activo
  Future<void> stopScanning() async {
    if (!_isScanning) {
      return;
    }

    try {
      await fbp.FlutterBluePlus.stopScan();
      await _scanSubscription?.cancel();
      _scanSubscription = null;
      _isScanning = false;
      debugPrint('üõë Bluetooth scan stopped');
    } on Exception catch (e) {
      debugPrint('‚ùå Error stopping scan: $e');
    }
  }

  /// Comenzar escaneo de dispositivos wearables
  Future<void> startScanning({
    final Duration timeout = const Duration(seconds: 30),
  }) async {
    if (_isScanning) {
      debugPrint('üîç Already scanning, skipping...');
      return;
    }

    if (!_connectionState.isReady) {
      debugPrint('‚ùå Cannot scan - Bluetooth not ready');
      throw Exception('Bluetooth not ready: ${_connectionState.errorMessage}');
    }

    // Limpiar cache de logs para permitir logging de dispositivos en nuevo scan
    _loggedDevices.clear();

    try {
      debugPrint('üîç Starting Bluetooth scan for BLE devices...');

      // üîß IMPORTANTE: Cancelar subscription ANTES de iniciar nuevo scan
      await _scanSubscription?.cancel();
      _scanSubscription = null;

      // üîß IMPORTANTE: Asegurar que no hay scan previo activo
      if (await fbp.FlutterBluePlus.isScanning.first) {
        debugPrint('‚ö†Ô∏è Previous scan still active, stopping it first...');
        await fbp.FlutterBluePlus.stopScan();
        await Future.delayed(
          const Duration(milliseconds: 300),
        ); // Wait for cleanup
      }

      // Comenzar escaneo con flutter_blue_plus
      // ‚úÖ flutter_blue_plus maneja el timeout autom√°ticamente y detiene el scan
      await fbp.FlutterBluePlus.startScan(timeout: timeout);

      // Escuchar resultados del escaneo
      _scanSubscription = fbp.FlutterBluePlus.scanResults.listen((
        final results,
      ) {
        for (final result in results) {
          final device = result.device;

          // Log solo si es la primera vez que vemos este dispositivo
          final deviceKey = '${device.platformName}-${device.remoteId.str}';
          if (!_loggedDevices.contains(deviceKey)) {
            debugPrint(
              'üì° BLE Device Found: "${device.platformName.isNotEmpty ? device.platformName : 'Unknown Device'}" (${device.remoteId.str})',
            );
            _loggedDevices.add(deviceKey);
          }

          // ‚ùå DISABLED: Temp connections cause infinite loop and battery drain
          // Services will be discovered when user explicitly connects
          // _discoverServicesForScannedDevice(device, result);

          // ‚úÖ OPTIMIZED: Just emit device with advertisement data
          _emitScannedDeviceWithAdvertisementData(device, result);
        }
      });
    } on Exception catch (e) {
      debugPrint('‚ùå Error during scan: $e');
      // üîß Detener scan en caso de error - el stream actualizar√° _isScanning
      await fbp.FlutterBluePlus.stopScan();
      _updateConnectionState(
        _connectionState.copyWith(
          isScanning: false,
          errorMessage: 'Scan failed: $e',
        ),
      );
      rethrow;
    }
  }

  /// ‚úÖ OPTIMIZED: Emit scanned device using ONLY advertisement data (no temp connection)
  ///
  /// **Benefits:**
  /// - No battery drain from temp connections
  /// - No connection loop issues
  /// - Faster scan results
  /// - Services discovered when user explicitly connects
  ///
  /// **Parameters:**
  /// - [device]: FlutterBluePlus device from scan result
  /// - [scanResult]: Scan result with advertisement data
  void _emitScannedDeviceWithAdvertisementData(
    final fbp.BluetoothDevice device,
    final fbp.ScanResult scanResult,
  ) {
    final deviceId = device.remoteId.str;
    final deviceName =
        device.platformName.isNotEmpty ? device.platformName : 'Unknown Device';

    // üéØ CR√çTICO: Cachear el device REAL del scan para uso posterior
    // Esto evita crear una nueva instancia con fromId() que puede fallar
    _connectedDevices[deviceId] = device;

    // Create device using ONLY advertisement data (no connection required)
    final scannedDevice = BluetoothDevice.fromBasicInfo(
      deviceId: deviceId,
      name: deviceName,
      services: scanResult.advertisementData.serviceUuids
          .map((final s) => BleUuidUtils.toShortUuid(s.toString()))
          .toList(),
      rssi: scanResult.rssi,
      paired: false,
      isSystemDevice: false,
    );

    // Cache and emit
    _scannedDevices[deviceId] = scannedDevice;
    _rawBleDeviceController.add(scannedDevice);
  }

  /// üîç Obtener dispositivos BONDED (emparejados en Android Settings)
  ///
  /// ‚ö†Ô∏è **CRITICAL BUG ENCONTRADO** - Issue flutter_blue_plus #1226:
  /// `FlutterBluePlus.systemDevices()` en Android est√° ROTO:
  /// - Internamente llama a: `mBluetoothManager.getConnectedDevices(BluetoothProfile.GATT)`
  /// - En Android 11-12, este m√©todo SIEMPRE retorna lista vac√≠a
  /// - Es un **bug de AOSP (Android OS)**, no fixeable a nivel flutter_blue_plus
  /// - Confirmado por el mantenedor: "open a issue with AOSP if its broken"
  ///
  /// ‚úÖ **SOLUCI√ìN - Usar bondedDevices en vez de systemDevices**:
  /// `FlutterBluePlus.bondedDevices` S√ç funciona de forma confiable en Android:
  /// - Retorna dispositivos emparejados via Android Settings ‚Üí Bluetooth
  /// - Funciona en TODAS las versiones de Android
  /// - **REQUISITO**: Usuario debe emparejar Smart Band 10 en Settings primero
  ///
  /// **WORKFLOW ESPERADO**:
  /// 1. Usuario empareja Smart Band 10 en Android Settings ‚Üí Bluetooth
  /// 2. Este m√©todo retorna Smart Band 10 en la lista
  /// 3. Llamar device.connect() para conectar TU app al dispositivo
  ///
  /// **Referencias**:
  /// - Issue: https://github.com/chipweinberger/flutter_blue_plus/issues/1226
  /// - Android docs: https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#getBondedDevices()
  Future<List<BluetoothDevice>> getSystemDevices() async {
    try {
      debugPrint('üîç Getting BONDED devices (paired in Android Settings)...');
      debugPrint('üì± Platform: Android');
      debugPrint('üöÄ Using: FlutterBluePlus.bondedDevices');

      // ‚úÖ PASO 1: Obtener dispositivos ya conectados a nivel de sistema (GROUND TRUTH)
      final alreadyConnectedDevices = fbp.FlutterBluePlus.connectedDevices;
      final alreadyConnectedIds = alreadyConnectedDevices
          .map((final d) => d.remoteId.str.toUpperCase())
          .toSet();

      debugPrint(
        'üîç Already connected devices at system level: ${alreadyConnectedIds.length}',
      );
      for (final d in alreadyConnectedDevices) {
        debugPrint('   ‚úÖ ${d.platformName} (${d.remoteId.str})');
      }

      // ‚úÖ PASO 2: Get bonded (paired) devices - RELIABLE on Android
      // Unlike systemDevices (broken), bondedDevices works consistently
      final bondedDevices = await fbp.FlutterBluePlus.bondedDevices;

      debugPrint('Bonded devices:');
      for (final device in bondedDevices) {
        final deviceId = device.remoteId.str;
        final deviceName = device.platformName.isNotEmpty
            ? device.platformName
            : 'Unknown Device';

        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        debugPrint('üì± Device: $deviceName ($deviceId)');

        // 1Ô∏è‚É£ Estado ANTES de intentar conectar
        final bondStateBefore = await device.bondState.first;
        final isConnectedBefore = device.isConnected;
        final connectionStateBefore = await device.connectionState.first;

        debugPrint('   üîê Bond State: $bondStateBefore');
        debugPrint('   üîó Is Connected (sync): $isConnectedBefore');
        debugPrint('   üì° Connection State (stream): $connectionStateBefore');
        debugPrint('   üîÑ AutoConnect Enabled: ${device.isAutoConnectEnabled}');

        // üîß FIX: Verificar estado REAL con connectedDevices (m√°s confiable)
        final actuallyConnected = alreadyConnectedIds.contains(
          deviceId.toUpperCase(),
        );
        debugPrint(
          '   üéØ Actually connected (system level): $actuallyConnected',
        );

        // 2Ô∏è‚É£ Simplemente cachear los dispositivos bonded sin conectar autom√°ticamente
        if (actuallyConnected) {
          debugPrint('   ‚úÖ Already connected at system level, caching device');
          // üéØ Cachear el device conectado para uso posterior
          _connectedDevices[deviceId] = device;
        } else {
          debugPrint(
            '   üìã Device bonded but not connected (user can connect manually)',
          );
          // Tambi√©n cacheamos dispositivos bonded aunque no est√©n conectados
          _connectedDevices[deviceId] = device;
        }

        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      }

      if (bondedDevices.isEmpty) {
        return [];
      }

      // Convert fbp.BluetoothDevice ‚Üí our BluetoothDevice model
      final bluetoothDevices = <BluetoothDevice>[];

      for (final device in bondedDevices) {
        final deviceId = device.remoteId.str;
        final deviceName = device.platformName.isNotEmpty
            ? device.platformName
            : 'System Device';

        debugPrint('   üì± System Device: $deviceName ($deviceId)');

        // üéØ CR√çTICO: Cachear el device REAL de bondedDevices para uso posterior
        // Esto evita crear una nueva instancia con fromId() que puede fallar
        _connectedDevices[deviceId] = device;
        debugPrint(
          '   ‚úÖ Cached real fbp.BluetoothDevice instance for $deviceId',
        );

        final bluetoothDevice = BluetoothDevice.fromBasicInfo(
          deviceId: deviceId,
          name: deviceName,
          services: [], // Will be discovered on connection
          rssi: null,
          paired: true,
          isSystemDevice: true, // ‚úÖ Mark as system device
        );

        bluetoothDevices.add(bluetoothDevice);
      }

      debugPrint(
        '‚úÖ Converted ${bluetoothDevices.length} system devices to BluetoothDevice',
      );
      debugPrint(
        '‚úÖ Cached ${bondedDevices.length} real fbp.BluetoothDevice instances',
      );
      return bluetoothDevices;
    } on Exception catch (e, stackTrace) {
      debugPrint('‚ùå Error getting system devices: $e');
      debugPrint('üìú Stack trace: $stackTrace');
      return [];
    }
  }

  // ‚ùå REMOVED: pairDevice() function - REDUNDANT
  //
  // Raz√≥n: En Android, el pairing ocurre autom√°ticamente durante bleDevice.connect()
  // No necesitamos una funci√≥n separada para pairing - connectDevice() ya lo incluye
  //
  // Migraci√≥n: Usar connectDevice() directamente que ya incluye pairing impl√≠cito

  /// üîå Conectar BLE b√°sico SIN autenticaci√≥n (para uso interno)
  ///
  /// Solo establece la conexi√≥n BLE y descubre servicios.
  /// NO ejecuta autenticaci√≥n Xiaomi ni l√≥gica de alto nivel.
  ///
  /// **Uso interno**: XiaomiAuthService para reconexi√≥n limpia
  Future<fbp.BluetoothDevice> connectBleOnly(final String deviceId) async {
    try {
      debugPrint('üîå Establishing basic BLE connection: $deviceId');

      final bleDevice = await getBluetoothDeviceAsync(deviceId);

      if (!bleDevice.isConnected) {
        await bleDevice.connect(mtu: null, license: fbp.License.free);
        debugPrint('‚úÖ BLE connected');
      } else {
        debugPrint('‚úÖ Already connected');
      }

      // Discover services to verify connection is real
      final services = await bleDevice.discoverServices();
      debugPrint('‚úÖ Services discovered: ${services.length}');

      return bleDevice;
    } catch (e) {
      debugPrint('‚ùå BLE connection failed: $e');
      rethrow;
    }
  }

  /// ‚úÖ SIMPLIFICADO: Conectar a dispositivo con flutter_blue_plus directo
  Future<ConnectionResult> connectDevice(final String deviceId) async {
    try {
      debugPrint('üîó Connecting to device: $deviceId (includes auto-pairing)');
      final stopwatch = Stopwatch()..start();

      // üßº CR√çTICO: Limpiar cache GATT antes de conectar (reconexiones)
      if (_connectedDevices.containsKey(deviceId)) {
        debugPrint('üßº Previous connection detected, refreshing GATT cache...');
        await _refreshGattCache(deviceId);
      }

      // ‚úÖ Paso 1: Obtener dispositivo y conectar (incluye pairing autom√°tico)
      final bleDevice = await getBluetoothDeviceAsync(deviceId);
      _connectedDevices[deviceId] = bleDevice;

      if (!bleDevice.isConnected) {
        // üîß Usar autoConnect=false para evitar problemas de cache
        // Seg√∫n la investigaci√≥n, autoConnect puede agravar problemas de cache GATT
        // Note: flutter_blue_plus handles pairing automatically during connect()
        await bleDevice.connect(mtu: null, license: fbp.License.free);
        debugPrint('‚úÖ BLE connection established (pairing included)');
      } else {
        debugPrint('‚úÖ Device already connected, reusing connection');
      }

      // üîß Configurar listeners oficiales de flutter_blue_plus
      _setupServicesResetListener(deviceId, bleDevice);
      _setupConnectionStateListener(deviceId, bleDevice);

      // PASO 2: Detectar si requiere autenticaci√≥n Xiaomi
      final deviceName =
          _scannedDevices[deviceId]?.name ?? bleDevice.platformName;
      final deviceConfig = await SupportedDevicesConfig.detectDevice(
        deviceName,
      );

      if (deviceConfig != null && deviceConfig.requiresAuth) {
        debugPrint('‚úÖ Xiaomi device detected, starting authentication...');

        // Cargar implementation y crear auth service
        final deviceImpl = await DeviceImplementationLoader.load(
          deviceConfig.deviceType,
        );
        final authService = XiaomiAuthService(
          deviceId: deviceId,
          bleService: this,
          deviceImplementation: deviceImpl,
        );
        _xiaomiAuthServices[deviceId] = authService;
        _deviceTypes[deviceId] = deviceConfig.deviceType;

        // C√≥digo simplificado para reemplazar l√≠neas 784-827
        // Autenticar directamente (XiaomiAuthService har√° discoverServices internamente)
        final authResult = await authService.authenticate();

        if (!authResult.success) {
          // Verificar si es problema de authKey faltante
          if (authResult.errorMessage?.contains('No credentials found') ==
              true) {
            debugPrint('‚ö†Ô∏è No authKey found, need extraction');
            return ConnectionResult.failure(deviceId, 'authkey_required');
          }

          // Otros errores de autenticaci√≥n
          debugPrint('‚ùå Authentication failed: ${authResult.errorMessage}');
          _xiaomiAuthServices.remove(deviceId);
          return ConnectionResult.failure(
            deviceId,
            authResult.errorMessage ?? 'Authentication failed',
          );
        }

        debugPrint('‚úÖ Authentication successful!');
        stopwatch.stop();
        return ConnectionResult.success(
          deviceId,
          connectionTime: stopwatch.elapsed,
        );
      }

      // PASO 3: Dispositivo no-Xiaomi (gen√©rico)
      debugPrint('üì± Generic BLE device, no authentication needed');
      _deviceTypes[deviceId] = 'generic';
      debugPrint(
        '‚úÖ Connection completed in ${stopwatch.elapsedMilliseconds}ms',
      );

      return ConnectionResult.success(
        deviceId,
        connectionTime: stopwatch.elapsed,
      );
    } on PlatformException catch (e) {
      final errorCode = _parseGattErrorCode(e.message);
      debugPrint('‚ùå Connection failed: $e (code: $errorCode)');

      // üö® Detectar si es un error de cache GATT corrupto
      if (_isGattCacheError(errorCode, e.message)) {
        debugPrint(
          'üßº GATT cache error detected, attempting refresh and retry...',
        );
        await _refreshGattCache(deviceId);

        // Opci√≥n: Podr√≠amos reintentar aqu√≠, pero mejor dejamos que sea manual
        // para evitar bucles infinitos
        debugPrint('üí° Try reconnecting after GATT cache refresh');
      }

      return ConnectionResult.failure(
        deviceId,
        e.message ?? e.toString(),
        errorCode: errorCode,
      );
    } on Exception catch (e) {
      debugPrint('‚ùå Connection failed: $e');

      // üö® Tambi√©n verificar errores generales que podr√≠an ser cache
      if (_isGattCacheError(null, e.toString())) {
        debugPrint('üßº Potential GATT cache issue detected in generic error');
        await _refreshGattCache(deviceId);
      }

      return ConnectionResult.failure(deviceId, e.toString());
    }
  }

  /// üßº Limpiar cache GATT corrupto (Soluci√≥n com√∫n para Android BLE)
  /// Esta funci√≥n resuelve el problema donde despu√©s de una desconexi√≥n,
  /// las reconexiones fallan por cache GATT corrupto
  Future<void> _refreshGattCache(final String deviceId) async {
    try {
      debugPrint(
        'üßº Clearing GATT cache using official flutter_blue_plus method: $deviceId',
      );

      final bleDevice = _getBluetoothDevice(deviceId);

      // üîß M√©todo 1: Usar el m√©todo oficial clearGattCache() de flutter_blue_plus
      try {
        await bleDevice.clearGattCache();
        debugPrint('‚úÖ Official clearGattCache() completed successfully');
      } on Exception catch (e) {
        debugPrint('‚ö†Ô∏è Official clearGattCache() failed: $e');

        // üîß Fallback: M√©todo manual si el oficial falla
        if (bleDevice.isConnected) {
          await bleDevice.discoverServices();
          debugPrint('‚úÖ Fallback: manual service rediscovery completed');
        }
      }

      // üîß M√©todo 2: Limpiar cache local de nuestro servicio
      _discoveredServices.remove(deviceId);

      // üîß M√©todo 3: Cancelar subscriptions para evitar referencias stale
      final keysToRemove = _characteristicSubscriptions.keys
          .where((final key) => key.startsWith('$deviceId:'))
          .toList();

      for (final key in keysToRemove) {
        await _characteristicSubscriptions[key]?.cancel();
        _characteristicSubscriptions.remove(key);
      }

      debugPrint('‚úÖ GATT cache cleanup completed for $deviceId');
    } on Exception catch (e) {
      debugPrint('‚ùå Error refreshing GATT cache: $e');
    }
  }

  /// Configurar listener oficial onServicesReset de flutter_blue_plus
  void _setupServicesResetListener(
    final String deviceId,
    final fbp.BluetoothDevice bleDevice,
  ) {
    // Usar el stream oficial para detectar cuando los servicios cambian
    bleDevice.onServicesReset.listen(
      (_) {
        debugPrint(
          'üîÑ Services Reset detected for $deviceId - re-discovering services',
        );
        // Ejecutar redescubrimiento de forma as√≠ncrona pero no bloquear el listener
        _handleServicesReset(deviceId, bleDevice);
      },
      onError: (final error) {
        debugPrint('‚ùå onServicesReset stream error for $deviceId: $error');
      },
    );
  }

  /// Manejar reset de servicios de forma as√≠ncrona
  Future<void> _handleServicesReset(
    final String deviceId,
    final fbp.BluetoothDevice bleDevice,
  ) async {
    try {
      // Re-descubrir servicios cuando cambian (m√©todo oficial)
      await bleDevice.discoverServices();
      debugPrint('‚úÖ Service rediscovery completed after Services Reset');
    } on Exception catch (e) {
      debugPrint('‚ùå Error re-discovering services after reset: $e');
    }
  }

  /// Configurar listener oficial connectionState de flutter_blue_plus
  void _setupConnectionStateListener(
    final String deviceId,
    final fbp.BluetoothDevice bleDevice,
  ) {
    // Usar el stream oficial para monitorear estados de conexi√≥n
    bleDevice.connectionState.listen(
      (final fbp.BluetoothConnectionState state) async {
        debugPrint('üîó Connection state changed for $deviceId: $state');

        if (state == fbp.BluetoothConnectionState.disconnected) {
          // Usar la propiedad oficial disconnectReason de flutter_blue_plus
          final disconnectReason = bleDevice.disconnectReason;
          if (disconnectReason != null) {
            debugPrint(
              'üìä Official disconnect reason: ${disconnectReason.code} - ${disconnectReason.description}',
            );

            // Detectar problemas de GATT cache usando c√≥digos oficiales
            if (_isGattCacheError(
              disconnectReason.code?.toString(),
              disconnectReason.description,
            )) {
              debugPrint(
                'üßº GATT cache corruption detected, refreshing cache...',
              );
              await _refreshGattCache(deviceId);
            }
          }

          // Seg√∫n la documentaci√≥n oficial: "you must always re-discover services after disconnection!"
          debugPrint(
            'üîÑ Connection lost - will need to re-discover services on next connect',
          );
          _discoveredServices.remove(deviceId);
        }
      },
      onError: (final error) {
        debugPrint('‚ùå connectionState stream error for $deviceId: $error');
      },
    );
  }

  /// Desconectar dispositivo (SOLO desconexi√≥n BLE de bajo nivel)
  Future<void> disconnectDevice(final String deviceId) async {
    try {
      debugPrint('üîå Disconnecting BLE device: $deviceId');

      // Cancelar monitoreo de conexi√≥n
      stopConnectionMonitoring(deviceId);

      // üîß NUEVO: Limpiar cache de servicios descubiertos
      _discoveredServices.remove(deviceId);

      // üîß NUEVO: Cancelar todas las subscriptions de caracter√≠sticas de este dispositivo
      final keysToRemove = _characteristicSubscriptions.keys
          .where((final key) => key.startsWith('$deviceId:'))
          .toList();

      for (final key in keysToRemove) {
        debugPrint('üßπ Canceling characteristic subscription: $key');
        await _characteristicSubscriptions[key]?.cancel();
        _characteristicSubscriptions.remove(key);
      }

      // Desconectar Bluetooth usando flutter_blue_plus
      final bleDevice = _getBluetoothDevice(deviceId);
      await bleDevice.disconnect();

      // üßº CR√çTICO: Limpiar cache GATT despu√©s de desconexi√≥n
      await _refreshGattCache(deviceId);

      debugPrint('‚úÖ BLE device $deviceId disconnected successfully');
    } on Exception catch (e) {
      debugPrint('‚ùå Error disconnecting BLE device $deviceId: $e');
    }
  }

  /// Obtener estado detallado de un dispositivo BLE puro
  Future<WearableDevice> getDeviceStatus(final String deviceId) async {
    try {
      // Crear instancia BLE pura sin conocer WearableDevice
      final bleDevice = _getBluetoothDevice(deviceId);

      // Verificar conexi√≥n BLE
      final isConnected = bleDevice.isConnected;

      return WearableDevice(
        deviceId: deviceId,
        name: 'BLE Device', // Default name
        deviceTypeId: 'smartwatch',
        connectionState: isConnected
            ? ConnectionState.connected
            : ConnectionState.disconnected,
        rssi: -60, // Default RSSI for BLE
        lastSeen: DateTime.now(),
      );
    } on Exception catch (e) {
      debugPrint('‚ùå Error getting BLE device status: $e');
      return WearableDevice(
        deviceId: deviceId,
        name: 'BLE Device',
        deviceTypeId: 'smartwatch',
        connectionState: ConnectionState.error,
        rssi: -100, // Very weak signal
        lastSeen: DateTime.now(),
      );
    }
  }

  ///
  /// **NEW STRATEGY**:
  /// - Battery reading is now EXCLUSIVELY done via BT_CLASSIC SPP protocol
  /// - Handled by XiaomiConnectionOrchestrator._readBatteryViaBtClassic()
  /// - Called AFTER authentication completes successfully
  /// - No BLE characteristic access during or immediately after auth
  ///
  /// **Migration Path**:
  /// - getDeviceStatus() ‚Üí Should use orchestrator.batteryStream instead
  /// - enrichDeviceMetadata() ‚Üí Skip battery reading during enrichment
  /// - Any UI code ‚Üí Subscribe to orchestrator.batteryStream  /// Monitorear estado de conexi√≥n usando Universal BLE connectionStream con callbacks

  /// Detener monitoreo de conexi√≥n para un dispositivo espec√≠fico
  void stopConnectionMonitoring(final String deviceId) {
    _connectionStreams[deviceId]?.cancel();
    _connectionStreams.remove(deviceId);

    debugPrint('üì° Stopped connection monitoring for device: $deviceId');
  }

  /// Descubrir servicios BLE de un dispositivo (debe estar conectado)
  Future<List<String>> discoverServices(final String deviceId) async {
    try {
      debugPrint('üîç Discovering BLE services for device: $deviceId');

      // Crear instancia BLE pura
      final bleDevice = _getBluetoothDevice(deviceId);

      // Verificar conexi√≥n BLE
      final isConnected = bleDevice.isConnected;
      if (!isConnected) {
        debugPrint('‚ö†Ô∏è Device $deviceId not connected, connecting first...');
        // ‚ö†Ô∏è mtu: null es REQUERIDO cuando se usa autoConnect (incompatible)
        await bleDevice.connect(
          autoConnect: true,
          mtu: null, // Required with autoConnect
          timeout: const Duration(seconds: 15),
          license: fbp.License.free,
        );
        debugPrint('üîó Connected to device for service discovery');
      }

      // Descubrir servicios usando flutter_blue_plus
      final services = await bleDevice.discoverServices();
      final serviceUuids =
          services.map((final s) => s.serviceUuid.toString()).toList();

      debugPrint('‚úÖ Discovered ${serviceUuids.length} services for $deviceId');
      for (final uuid in serviceUuids) {
        final shortUuid = uuid.length >= 8
            ? uuid.substring(4, 8).toUpperCase()
            : uuid.toUpperCase();
        debugPrint('   üì° $uuid (short: $shortUuid)');
      }

      return serviceUuids;
    } on Exception catch (e) {
      debugPrint('‚ùå Error discovering services for $deviceId: $e');
      return [];
    }
  }

  /// üìù Escribir valor a una caracter√≠stica BLE espec√≠fica
  ///
  /// M√©todo p√∫blico para que upper services (como XiaomiKeepAliveService)
  /// puedan escribir comandos BLE sin importar universal_ble directamente.
  ///
  /// [deviceId] - ID del dispositivo BLE
  /// [serviceUuid] - UUID del servicio (puede ser short UUID como '180D' o full UUID)
  /// [characteristicUuid] - UUID de la caracter√≠stica
  /// [value] - Bytes a escribir
  /// [withResponse] - Si esperar respuesta del dispositivo (default: true)

  /// üîî Habilitar/deshabilitar notificaciones en una caracter√≠stica BLE
  ///
  /// M√©todo p√∫blico para que upper services puedan suscribirse a notificaciones.
  ///
  /// [deviceId] - ID del dispositivo BLE
  /// [serviceUuid] - UUID del servicio
  /// [characteristicUuid] - UUID de la caracter√≠stica
  /// [enable] - true para habilitar, false para deshabilitar
  Future<void> setNotifiable({
    required final String deviceId,
    required final String serviceUuid,
    required final String characteristicUuid,
    required final bool enable,
  }) async {
    try {
      debugPrint(
        'üêõ DEBUG: setNotifiable called - ${enable ? 'ENABLE' : 'DISABLE'} for $characteristicUuid on $deviceId',
      );
      debugPrint('üêõ DEBUG: Service UUID: $serviceUuid');

      // Crear instancia BLE pura
      final bleDevice = _getBluetoothDevice(deviceId);

      // Verificar conexi√≥n BLE
      final isConnected = bleDevice.isConnected;
      debugPrint('üêõ DEBUG: Device isConnected: $isConnected');
      if (!isConnected) {
        throw Exception('Device $deviceId not connected');
      }

      // üéØ Expandir UUIDs cortos a completos para flutter_blue_plus
      final fullServiceUuid = BleUuidUtils.expandUuid(serviceUuid);
      final fullCharUuid = BleUuidUtils.expandUuid(characteristicUuid);

      debugPrint(
        'üîç Expanded UUIDs: $serviceUuid ‚Üí $fullServiceUuid, $characteristicUuid ‚Üí $fullCharUuid',
      );

      // Obtener la caracter√≠stica
      debugPrint(
        'üêõ DEBUG: Getting characteristic $fullCharUuid from service $fullServiceUuid...',
      );

      // üîß CRITICAL FIX: Use cached services to avoid re-triggering GATT_INTERNAL_ERROR (129)
      // on Xiaomi devices that reject re-subscription to Service Changed (2a05)
      List<fbp.BluetoothService> services;
      if (_discoveredServices.containsKey(deviceId)) {
        debugPrint('‚úÖ Using cached services for $deviceId');
        services = _discoveredServices[deviceId]!;
      } else {
        debugPrint('üîç Discovering services for $deviceId (first time)...');
        services = await bleDevice.discoverServices();
        _discoveredServices[deviceId] = services;
        debugPrint('   ‚úÖ Cached ${services.length} services');
      }

      // Buscar servicio (with UUID normalization - same as _discoverCharacteristics)
      final normalizedServiceTarget = _normalizeUuidForComparison(
        fullServiceUuid,
      );
      debugPrint(
        'üîç Looking for service: $fullServiceUuid ‚Üí normalized: $normalizedServiceTarget',
      );

      final service = services.firstWhere(
        (final s) =>
            _normalizeUuidForComparison(s.serviceUuid.toString()) ==
            normalizedServiceTarget,
        orElse: () => throw Exception(
          'Service "$fullServiceUuid" not found. Available services: ${services.map((final s) => s.serviceUuid.toString()).join(", ")}',
        ),
      );

      debugPrint('‚úÖ Service found: ${service.serviceUuid}');

      // Buscar caracter√≠stica (with UUID normalization)
      final normalizedCharTarget = _normalizeUuidForComparison(fullCharUuid);
      debugPrint(
        'üîç Looking for characteristic: $fullCharUuid ‚Üí normalized: $normalizedCharTarget',
      );

      final characteristic = service.characteristics.firstWhere(
        (final c) =>
            _normalizeUuidForComparison(c.characteristicUuid.toString()) ==
            normalizedCharTarget,
        orElse: () => throw Exception(
          'Characteristic "$fullCharUuid" not found in service "$fullServiceUuid". Available: ${service.characteristics.map((final c) => c.characteristicUuid.toString()).join(", ")}',
        ),
      );
      debugPrint('üêõ DEBUG: Characteristic obtained successfully');

      // Habilitar/deshabilitar notificaciones
      if (enable) {
        debugPrint('üêõ DEBUG: Calling characteristic.setNotifyValue(true)...');
        await characteristic.setNotifyValue(true);
        debugPrint('üêõ DEBUG: Subscribe completed');

        debugPrint(
          'üêõ DEBUG: Setting up onValueReceived listener for $characteristicUuid...',
        );

        // ‚úÖ CRITICAL FIX: Cancel previous subscription if exists (prevent duplicates)
        final subscriptionKey = '$deviceId:$characteristicUuid';
        if (_characteristicSubscriptions.containsKey(subscriptionKey)) {
          debugPrint('üßπ Canceling previous subscription for $subscriptionKey');
          await _characteristicSubscriptions[subscriptionKey]?.cancel();
          _characteristicSubscriptions.remove(subscriptionKey);
        }

        // ‚úÖ Mejor pr√°ctica: Auto-cleanup cuando hay error o disconnect
        final subscription = characteristic.onValueReceived.listen(
          (final value) {
            // üî¥ TEST #13: LOG COMPLETAMENTE RAW - SIN FILTROS
            debugPrint(
              'üêõ DEBUG: [$characteristicUuid] RAW notification! Length: ${value.length}, Bytes: ${value.toList()}',
            );

            // üÜï EMIT to rawBleDataStream for upper services to consume
            final bleDataPacket = BleDataPacket(
              deviceId: deviceId,
              serviceUuid: serviceUuid,
              characteristicUuid: characteristicUuid,
              rawData: value.toList(),
              timestamp: DateTime.now(),
            );
            _rawBleDataController.add(bleDataPacket);
          },
          onError: (final error, final stackTrace) {
            // üî¥ TEST #13: LOG EXPL√çCITO DE ERRORES
            debugPrint(
              'üêõ DEBUG: [$characteristicUuid] Listener ERROR: $error',
            );
          },
          onDone: () {
            // üî¥ TEST #13: LOG CUANDO LISTENER SE CIERRA
            debugPrint('üêõ DEBUG: [$characteristicUuid] Listener DONE');
            _characteristicSubscriptions.remove(subscriptionKey); // Cleanup
          },
          cancelOnError:
              false, // üî¥ TEST #13: NO CANCELAR EN ERROR - ver si hay errores silenciosos
        );

        // ‚úÖ Store subscription for later cleanup
        _characteristicSubscriptions[subscriptionKey] = subscription;

        // ‚úÖ Auto-cleanup cuando el dispositivo se desconecta
        bleDevice.cancelWhenDisconnected(subscription);

        debugPrint('‚úÖ Notifications enabled for $characteristicUuid');
      } else {
        // Disable notifications - also cleanup subscription
        await characteristic.setNotifyValue(false);

        final subscriptionKey = '$deviceId:$characteristicUuid';
        if (_characteristicSubscriptions.containsKey(subscriptionKey)) {
          debugPrint(
            'üßπ Canceling subscription for $subscriptionKey (disable)',
          );
          await _characteristicSubscriptions[subscriptionKey]?.cancel();
          _characteristicSubscriptions.remove(subscriptionKey);
        }

        debugPrint('‚úÖ Notifications disabled for $characteristicUuid');
      }
    } on Exception catch (e) {
      debugPrint('‚ùå Error setting notifiable: $e');
      rethrow;
    }
  }

  // ============================================================================
  // üÜï GENERIC SERVICE SUBSCRIPTION (NEW ARCHITECTURE)
  // ============================================================================

  /// üéØ API S√öPER SIMPLE - Suscribirse a un data type usando device implementation JSONs
  ///
  /// Este es el m√©todo √öNICO y PRINCIPAL para suscribirse a caracter√≠sticas.
  /// Detecta autom√°ticamente el device type, carga su implementation JSON,
  /// y se suscribe a la caracter√≠stica correcta.
  ///
  /// [deviceId] - ID del dispositivo BLE
  /// [dataType] - Tipo de dato ('heart_rate', 'battery', 'spo2', 'temperature', etc.)
  /// [onData] - Callback para recibir datos
  /// [onError] - Callback opcional para errores
  ///
  /// Returns: StreamSubscription o null si no se encuentra el data type
  ///
  /// Ejemplo:
  /// ```dart
  /// await bleService.subscribeToDataType(
  ///   deviceId: 'XX:XX:XX:XX:XX:XX',
  ///   dataType: 'heart_rate',
  ///   onData: (data) => print('HR: $data'),
  /// );
  /// ```
  Future<StreamSubscription<BleDataPacket>?> subscribeToDataType({
    required final String deviceId,
    required final String dataType,
    required final Function(List<int> data) onData,
    final Function(Object error)? onError,
  }) async {
    try {
      debugPrint(
        '[BleService] üéØ Subscribing to $dataType for device $deviceId',
      );

      // 1Ô∏è‚É£ Obtener device type (con cache) o fallback a generic
      final deviceType = _deviceTypes[deviceId] ?? 'generic';
      debugPrint('[BleService] üì± Device type: $deviceType');

      // 2Ô∏è‚É£ Cargar device implementation (con fallback autom√°tico a generic)
      final deviceImpl = await DeviceImplementationLoader.loadOrGeneric(
        deviceType,
      );

      // 3Ô∏è‚É£ Buscar caracter√≠stica usando el index (O(1) lookup)
      final charInfo = deviceImpl.getCharacteristicForDataType(dataType);

      if (charInfo == null) {
        debugPrint(
          '[BleService] ‚ùå Data type "$dataType" not found in $deviceType implementation',
        );
        debugPrint(
          '[BleService]  Supported data types: ${deviceImpl.getSupportedDataTypes().join(', ')}',
        );
        onError?.call(
          Exception(
            'Data type "$dataType" not supported by $deviceType device',
          ),
        );
        return null;
      }

      debugPrint(
        '[BleService] ‚úÖ Found characteristic: ${charInfo.characteristicName} '
        '(${charInfo.characteristicUuid})',
      );

      // 4Ô∏è‚É£ Suscribirse usando el m√©todo gen√©rico de bajo nivel
      return await _subscribeToCharacteristic(
        deviceId: deviceId,
        serviceUuid: charInfo.serviceUuid,
        characteristicUuid: charInfo.characteristicUuid,
        onData: onData,
        onError: onError,
      );
    } on Exception catch (e) {
      debugPrint('[BleService] ‚ùå Error subscribing to $dataType: $e');
      onError?.call(e);
      return null;
    }
  }

  /// Desuscribirse de un data type
  ///
  /// [deviceId] - ID del dispositivo BLE
  /// [dataType] - Tipo de dato ('heart_rate', 'battery', 'spo2', etc.)
  ///
  /// Ejemplo:
  /// ```dart
  /// await bleService.unsubscribeFromDataType(
  ///   deviceId: 'XX:XX:XX:XX:XX:XX',
  ///   dataType: 'heart_rate',
  /// );
  /// ```
  Future<void> unsubscribeFromDataType({
    required final String deviceId,
    required final String dataType,
  }) async {
    try {
      debugPrint(
        '[BleService] üõë Unsubscribing from $dataType for device $deviceId',
      );

      // 1Ô∏è‚É£ Obtener device type (con cache) o fallback a generic
      final deviceType = _deviceTypes[deviceId] ?? 'generic';
      debugPrint('[BleService] üì± Device type: $deviceType');

      // 2Ô∏è‚É£ Cargar device implementation (con fallback autom√°tico a generic)
      final deviceImpl = await DeviceImplementationLoader.loadOrGeneric(
        deviceType,
      );

      // 3Ô∏è‚É£ Buscar caracter√≠stica usando el index (O(1) lookup)
      final charInfo = deviceImpl.getCharacteristicForDataType(dataType);

      if (charInfo == null) {
        debugPrint(
          '[BleService] ‚ùå Data type "$dataType" not found in $deviceType implementation',
        );
        throw Exception(
          'Data type "$dataType" not supported by $deviceType device',
        );
      }

      debugPrint(
        '[BleService] ‚úÖ Found characteristic: ${charInfo.characteristicName} '
        '(${charInfo.characteristicUuid})',
      );

      // 4Ô∏è‚É£ Desuscribirse usando setNotifiable con enable: false
      await setNotifiable(
        deviceId: deviceId,
        serviceUuid: charInfo.serviceUuid,
        characteristicUuid: charInfo.characteristicUuid,
        enable: false,
      );

      debugPrint('[BleService] ‚úÖ Successfully unsubscribed from $dataType');
    } on Exception catch (e) {
      debugPrint('[BleService] ‚ùå Error unsubscribing from $dataType: $e');
      rethrow;
    }
  }

  /// üîî Suscribirse a notificaciones de una caracter√≠stica espec√≠fica (M√âTODO PRIVADO)
  ///
  /// M√©todo gen√©rico de BAJO NIVEL para suscribirse a caracter√≠sticas BLE.
  /// ‚ö†Ô∏è NO usar directamente - usar subscribeToDataType() en su lugar.
  ///
  /// [deviceId] - ID del dispositivo BLE
  /// [serviceUuid] - UUID del servicio (puede ser short UUID como 'FE95')
  /// [characteristicUuid] - UUID de la caracter√≠stica
  /// [onData] - Callback para recibir datos de notificaciones
  /// [onError] - Callback opcional para errores
  ///
  /// Returns: StreamSubscription para cancelar la suscripci√≥n m√°s tarde
  Future<StreamSubscription<BleDataPacket>> _subscribeToCharacteristic({
    required final String deviceId,
    required final String serviceUuid,
    required final String characteristicUuid,
    required final Function(List<int> data) onData,
    final Function(Object error)? onError,
  }) async {
    try {
      debugPrint(
        '[BleService] üì° Subscribing to $characteristicUuid on $deviceId',
      );

      // Habilitar notificaciones en la caracter√≠stica
      await setNotifiable(
        deviceId: deviceId,
        serviceUuid: serviceUuid,
        characteristicUuid: characteristicUuid,
        enable: true,
      );

      // Filtrar el stream de datos crudos para esta caracter√≠stica espec√≠fica
      final subscription = rawBleDataStream
          .where(
        (final packet) =>
            packet.deviceId == deviceId &&
            packet.characteristicUuid.toUpperCase().contains(
                  characteristicUuid.toUpperCase().replaceAll('-', ''),
                ),
      )
          .listen(
        (final packet) {
          debugPrint(
            '[BleService] üì® Data for $characteristicUuid: ${packet.rawData.length} bytes',
          );
          onData(packet.rawData);
        },
        onError: (final error) {
          debugPrint(
            '[BleService] ‚ùå Subscription error for $characteristicUuid: $error',
          );
          onError?.call(error);
        },
      );

      debugPrint(
        '[BleService] ‚úÖ Subscribed to $characteristicUuid successfully',
      );

      return subscription;
    } on Exception catch (e) {
      debugPrint('[BleService] ‚ùå Error subscribing to characteristic: $e');
      rethrow;
    }
  }

  /// Limpiar recursos y cerrar streams
  void dispose() {
    _isInitialized = false; // Permitir re-inicializaci√≥n despu√©s del dispose
    _rawBleDeviceController.close();
    _connectionStateController.close();
    _rawBleDataController.close();

    // Cancelar streams de conexi√≥n
    for (final subscription in _connectionStreams.values) {
      subscription.cancel();
    }
    _connectionStreams.clear();

    debugPrint('üîµ BleService disposed');
  }

  /// ‚úÖ FASE C: Parsear c√≥digo de error GATT desde PlatformException
  ///
  /// Ejemplos de mensajes:
  /// - "GATT Error 147" ‚Üí "147"
  /// - "Error 133" ‚Üí "133"
  /// - "Connection failed with error code 19" ‚Üí "19"
  /// - "Unknown error" ‚Üí null
  static String? _parseGattErrorCode(final String? message) {
    if (message == null) return null;

    // Pattern 1: "GATT Error 147"
    final gattPattern = RegExp(r'GATT Error (\d+)');
    final gattMatch = gattPattern.firstMatch(message);
    if (gattMatch != null) {
      return gattMatch.group(1);
    }

    // Pattern 2: "Error 133"
    final errorPattern = RegExp(r'Error (\d+)');
    final errorMatch = errorPattern.firstMatch(message);
    if (errorMatch != null) {
      return errorMatch.group(1);
    }

    // Pattern 3: "error code 19" (case insensitive)
    final codePattern = RegExp(r'error code (\d+)', caseSensitive: false);
    final codeMatch = codePattern.firstMatch(message);
    if (codeMatch != null) {
      return codeMatch.group(1);
    }

    // Pattern 4: "REMOTE_USER_TERMINATED_CONNECTION" (status 19)
    if (message.contains('REMOTE_USER_TERMINATED_CONNECTION')) {
      return '19';
    }

    // Pattern 5: "GATT_INTERNAL_ERROR" (status 129)
    if (message.contains('GATT_INTERNAL_ERROR')) {
      return '129';
    }

    // Pattern 6: "GATT_ERROR" (status 133)
    if (message.contains('GATT_ERROR')) {
      return '133';
    }

    // No match found
    return null;
  }

  /// üö® Detectar si un error GATT indica cache corrupto
  /// Basado en investigaci√≥n de Stack Overflow sobre Android BLE
  static bool _isGattCacheError(
    final String? errorCode,
    final String? message,
  ) {
    if (errorCode == null && message == null) return false;

    // C√≥digos de error GATT que indican cache corrupto
    final cacheErrorCodes = ['19', '129', '133'];
    if (errorCode != null && cacheErrorCodes.contains(errorCode)) {
      return true;
    }

    // Mensajes de error que indican cache corrupto
    final cacheErrorMessages = [
      'REMOTE_USER_TERMINATED_CONNECTION',
      'GATT_INTERNAL_ERROR',
      'GATT_ERROR',
      'device is disconnected',
      'service discovery failed',
    ];

    if (message != null) {
      for (final errorMsg in cacheErrorMessages) {
        if (message.toLowerCase().contains(errorMsg.toLowerCase())) {
          return true;
        }
      }
    }

    return false;
  }

  // ============================================================================
  // BLE Characteristic Abstraction Layer (for auth protocols)
  // ============================================================================

  // ‚ùå DEPRECATED: subscribeToNotifications() eliminado
  // ‚úÖ USE: setNotifiable() instead - it properly sets up onValueReceived listener
  // Raz√≥n: subscribeToNotifications() solo hac√≠a setNotifyValue(true) pero NO configuraba
  // el listener de characteristic.onValueReceived, por lo que nunca recib√≠amos notificaciones.

  /// Unsubscribes from notifications on a specific characteristic.
  ///
  /// **Parameters:**
  /// - [deviceId]: Device MAC address
  /// - [serviceUuid]: Service UUID
  /// - [characteristicUuid]: Characteristic UUID
  ///
  /// **Returns:**
  /// - `true` if unsubscription succeeded
  /// - `false` if failed

  /// Writes data to a specific characteristic.
  ///
  /// **Purpose:** Abstraction for authentication protocol writes
  ///
  /// **Parameters:**
  /// - [deviceId]: Device MAC address
  /// - [serviceUuid]: Service UUID
  /// - [characteristicUuid]: Characteristic UUID
  /// - [data]: Bytes to write
  ///
  /// **Returns:**
  /// - `true` if write succeeded
  /// - `false` if failed
  ///
  /// **Example:**
  /// Request MTU (Maximum Transmission Unit) size
  ///
  /// Larger MTU allows sending bigger packets without fragmentation.
  /// Typical values: 23 (default), 247 (Gadgetbridge), 512 (max Android)
  ///
  /// **Example:**
  /// ```dart
  /// final mtu = await bleService.requestMtu(
  ///   deviceId: 'AA:BB:CC:DD:EE:FF',
  ///   mtu: 247,
  /// );
  /// ```
  Future<int> requestMtu({
    required final String deviceId,
    required final int mtu,
  }) async {
    try {
      final device = _connectedDevices[deviceId];
      if (device == null) {
        debugPrint('‚ùå Device not connected: $deviceId');
        return 23; // Default MTU
      }

      debugPrint('üì° Requesting MTU $mtu for $deviceId...');
      final negotiatedMtu = await device.requestMtu(mtu);
      debugPrint('‚úÖ MTU negotiated: $negotiatedMtu bytes');

      return negotiatedMtu;
    } on Exception catch (e) {
      debugPrint('‚ùå MTU request failed: $e');
      return 23; // Return default MTU on failure
    }
  }

  /// Read data from a BLE characteristic (one-shot read)
  ///
  /// Performs a single read operation from a BLE characteristic.
  /// Useful for reading static values like battery level, device info, etc.
  ///
  /// **Parameters:**
  /// - [deviceId]: Device MAC address
  /// - [serviceUuid]: Service UUID (can be short UUID like 'FE95')
  /// - [characteristicUuid]: Characteristic UUID
  ///
  /// **Returns:**
  /// - List&lt;int&gt; with the read data bytes if successful
  /// - `null` if read failed or device not connected
  ///
  /// **Example:**
  /// ```dart
  /// // Read battery level (BLE Battery Service 0x2A19)
  /// final batteryBytes = await bleService.readCharacteristic(
  ///   deviceId: 'AA:BB:CC:DD:EE:FF',
  ///   serviceUuid: '180F',
  ///   characteristicUuid: '2A19',
  /// );
  /// if (batteryBytes != null) {
  ///   final batteryLevel = batteryBytes[0]; // 0-100%
  /// }
  /// ```
  Future<List<int>?> readCharacteristic({
    required final String deviceId,
    required final String serviceUuid,
    required final String characteristicUuid,
  }) async {
    try {
      final device = _connectedDevices[deviceId];
      if (device == null) {
        debugPrint('‚ùå Device not connected: $deviceId');
        return null;
      }

      // üîß OPTIMIZACI√ìN: Usar cache de servicios o descubrir solo si no est√°n en cache
      List<fbp.BluetoothService> services;
      if (_discoveredServices.containsKey(deviceId)) {
        services = _discoveredServices[deviceId]!;
      } else {
        services = await device.discoverServices();
        _discoveredServices[deviceId] = services; // Cache para futuros reads
        debugPrint(
          'üîç Discovered and cached ${services.length} services for $deviceId',
        );
      }

      // Find service (with UUID normalization)
      final normalizedServiceTarget = _normalizeUuidForComparison(serviceUuid);
      final service = services.firstWhere(
        (final s) =>
            _normalizeUuidForComparison(s.uuid.toString()) ==
            normalizedServiceTarget,
        orElse: () => throw Exception('Service not found: $serviceUuid'),
      );

      // Find characteristic (with UUID normalization)
      final normalizedCharTarget = _normalizeUuidForComparison(
        characteristicUuid,
      );
      final characteristic = service.characteristics.firstWhere(
        (final c) =>
            _normalizeUuidForComparison(c.uuid.toString()) ==
            normalizedCharTarget,
        orElse: () =>
            throw Exception('Characteristic not found: $characteristicUuid'),
      );

      // ‚úÖ Read characteristic value
      final value = await characteristic.read();

      debugPrint(
        'üì• Read ${value.length} bytes from $deviceId / ${characteristicUuid.substring(0, 8)}...',
      );

      return value;
    } on Exception catch (e) {
      debugPrint('‚ùå Failed to read characteristic: $e');
      return null;
    }
  }

  /// Write data to a BLE characteristic
  ///
  /// **Example:**
  /// ```dart
  /// final written = await bleService.writeCharacteristic(
  ///   deviceId: 'AA:BB:CC:DD:EE:FF',
  ///   serviceUuid: '0000FE95-...',
  ///   characteristicUuid: '00000051-...',
  ///   data: protobufBytes,
  /// );
  /// ```
  Future<bool> writeCharacteristic({
    required final String deviceId,
    required final String serviceUuid,
    required final String characteristicUuid,
    required final List<int> data,
    final bool withoutResponse =
        false, // ‚úÖ NUEVO: soporte para WRITE_NO_RESPONSE
  }) async {
    try {
      final device = _connectedDevices[deviceId];
      if (device == null) {
        debugPrint('‚ùå Device not connected: $deviceId');
        return false;
      }

      // üîß OPTIMIZACI√ìN: Usar cache de servicios o descubrir solo si no est√°n en cache
      List<fbp.BluetoothService> services;
      if (_discoveredServices.containsKey(deviceId)) {
        services = _discoveredServices[deviceId]!;
      } else {
        services = await device.discoverServices();
        _discoveredServices[deviceId] = services; // Cache para futuros writes
        debugPrint(
          'üîç Discovered and cached ${services.length} services for $deviceId',
        );
      }

      // Find service (with UUID normalization)
      final normalizedServiceTarget = _normalizeUuidForComparison(serviceUuid);
      final service = services.firstWhere(
        (final s) =>
            _normalizeUuidForComparison(s.uuid.toString()) ==
            normalizedServiceTarget,
        orElse: () => throw Exception('Service not found: $serviceUuid'),
      );

      // Find characteristic (with UUID normalization)
      final normalizedCharTarget = _normalizeUuidForComparison(
        characteristicUuid,
      );
      final characteristic = service.characteristics.firstWhere(
        (final c) =>
            _normalizeUuidForComparison(c.uuid.toString()) ==
            normalizedCharTarget,
        orElse: () =>
            throw Exception('Characteristic not found: $characteristicUuid'),
      );

      // ‚úÖ ACTUALIZADO: Usar writeWithoutResponse si es necesario
      await characteristic.write(data, withoutResponse: withoutResponse);

      debugPrint(
        'üì§ Written ${data.length} bytes to $deviceId / ${characteristicUuid.substring(0, 8)}... (withoutResponse=$withoutResponse)',
      );

      return true;
    } on Exception catch (e) {
      debugPrint('‚ùå Failed to write characteristic: $e');
      return false;
    }
  }

  /// Waits for a notification from a specific characteristic with timeout.
  ///
  /// **Purpose:** Abstraction for authentication protocol responses
  ///
  /// **Parameters:**
  /// - [deviceId]: Device MAC address
  /// - [serviceUuid]: Service UUID
  /// - [characteristicUuid]: Characteristic UUID
  /// - [timeout]: Maximum wait duration
  ///
  /// **Returns:**
  /// - Notification data bytes if received
  /// - `null` if timeout or error
  ///
  /// **Example:**
  /// ```dart
  /// final response = await bleService.waitForNotification(
  ///   deviceId: 'AA:BB:CC:DD:EE:FF',
  ///   serviceUuid: '0000FE95-...',
  ///   characteristicUuid: '00000052-...',
  ///   timeout: Duration(seconds: 5),
  /// );
  /// ```
  Future<List<int>?> waitForNotification({
    required final String deviceId,
    required final String serviceUuid,
    required final String characteristicUuid,
    required final Duration timeout,
  }) async {
    try {
      final device = _connectedDevices[deviceId];
      if (device == null) {
        debugPrint('‚ùå Device not connected: $deviceId');
        return null;
      }

      final services = await device.discoverServices();

      // Find service (with UUID normalization)
      final normalizedServiceTarget = _normalizeUuidForComparison(serviceUuid);
      final service = services.firstWhere(
        (final s) =>
            _normalizeUuidForComparison(s.uuid.toString()) ==
            normalizedServiceTarget,
        orElse: () => throw Exception('Service not found: $serviceUuid'),
      );

      // Find characteristic (with UUID normalization)
      final normalizedCharTarget = _normalizeUuidForComparison(
        characteristicUuid,
      );
      final characteristic = service.characteristics.firstWhere(
        (final c) =>
            _normalizeUuidForComparison(c.uuid.toString()) ==
            normalizedCharTarget,
        orElse: () =>
            throw Exception('Characteristic not found: $characteristicUuid'),
      );

      // Wait for notification
      final notification = await characteristic.lastValueStream
          .timeout(timeout)
          .firstWhere((final value) => value.isNotEmpty);

      debugPrint(
        'üì• Received ${notification.length} bytes from $deviceId / ${characteristicUuid.substring(0, 8)}...',
      );

      return notification;
    } on TimeoutException {
      debugPrint(
        '‚è±Ô∏è Timeout waiting for notification from $deviceId / ${characteristicUuid.substring(0, 8)}...',
      );
      return null;
    } on Exception catch (e) {
      debugPrint('‚ùå Failed to wait for notification: $e');
      return null;
    }
  }

  /// Normalizes a BLE UUID to short format (4 characters) for comparison.
  ///
  /// Examples:
  /// - `0000FE95-0000-1000-8000-00805F9B34FB` ‚Üí `FE95`
  /// - `fe95` ‚Üí `FE95`
  /// - `FE95` ‚Üí `FE95`
  String _normalizeUuidForComparison(final String uuid) {
    final cleaned = uuid.toUpperCase().replaceAll('-', '');

    // Si tiene formato largo (32+ chars), extraer los 4 chars significativos
    if (cleaned.length >= 8) {
      return cleaned.substring(4, 8);
    }

    // Si ya es corto, devolver tal cual
    return cleaned;
  }

  /// Checks if a device has a specific service available.
  ///
  /// **Parameters:**
  /// - [deviceId]: Device MAC address
  /// - [serviceUuid]: Service UUID to check (accepts short or long format)
  ///
  /// **Returns:**
  /// - `true` if service exists
  /// - `false` if not found or device not connected
  ///
  /// **Note**: Compares UUIDs in normalized short format (e.g., FE95)

  /// Checks if a device has a specific characteristic available.
  ///
  /// **Parameters:**
  /// - [deviceId]: Device MAC address
  /// - [serviceUuid]: Service UUID (accepts short or long format)
  /// - [characteristicUuid]: Characteristic UUID (accepts short or long format)
  ///
  /// **Returns:**
  /// - `true` if characteristic exists
  /// - `false` if not found or device not connected
  ///
  /// **Note**: Compares UUIDs in normalized short format (e.g., FE95)

  /// Establece una conexi√≥n temporal al dispositivo para obtener informaci√≥n actualizada
  ///
  /// **Prop√≥sito:**
  /// - Conectar temporalmente a un dispositivo para refrescar su informaci√≥n
  /// - Descubrir servicios y caracter√≠sticas disponibles
  /// - Leer informaci√≥n b√°sica como RSSI
  /// - Preparar el dispositivo para operaciones posteriores
  ///
  /// **Par√°metros:**
  /// - [deviceId]: Direcci√≥n MAC del dispositivo
  /// - [timeout]: Tiempo m√°ximo para la conexi√≥n (default: 15 segundos)
  /// - [requestMtu]: MTU a solicitar (default: 247 bytes)
  ///
  /// **Retorna:**
  /// - [fbp.BluetoothDevice] conectado y listo para usar
  ///
  /// **Throws:**
  /// - [Exception] si no se puede conectar o el dispositivo no existe
  ///
  /// **Uso:**
  /// ```dart
  /// final connectedDevice = await bleService.connectTemporarily(
  ///   deviceId: 'AA:BB:CC:DD:EE:FF',
  ///   timeout: Duration(seconds: 20),
  /// );
  /// // El dispositivo queda conectado y listo para autenticaci√≥n
  /// ```
  Future<fbp.BluetoothDevice> connectTemporarily({
    required final String deviceId,
    final Duration timeout = const Duration(seconds: 15),
    final int requestMtu = 247,
  }) async {
    debugPrint('üîó BleService: Connecting temporarily to $deviceId...');

    try {
      // 1. Obtener dispositivo actualizado (evitar cache stale)
      debugPrint('   üì° Getting fresh device instance...');
      final bleDevice = await getBluetoothDeviceAsync(deviceId);

      debugPrint(
        '   ‚úÖ Got device: ${bleDevice.platformName} (${bleDevice.remoteId.str})',
      );

      // 2. Conectar si no est√° conectado
      if (!bleDevice.isConnected) {
        debugPrint('   üì∂ Connecting to device...');
        await bleDevice.connect(
          mtu: requestMtu, // MTU optimizado para SPP packets
          timeout: timeout,
          license: fbp.License.free,
        );
        debugPrint('   ‚úÖ Connected successfully');
      } else {
        debugPrint('   ‚úÖ Device already connected');
      }

      // 3. Esperar estabilizaci√≥n de la conexi√≥n
      await Future.delayed(const Duration(milliseconds: 500));

      // 4. Descubrir servicios para refrescar estado del dispositivo
      debugPrint('   üîç Discovering services...');
      final services = await bleDevice.discoverServices();
      debugPrint('   üìã Discovered ${services.length} services');

      // 5. Leer informaci√≥n b√°sica del dispositivo
      try {
        final rssi = await bleDevice.readRssi();
        debugPrint('   üì∂ Current RSSI: $rssi dBm');
      } on Exception catch (e) {
        debugPrint('   ‚ö†Ô∏è Could not read RSSI: $e');
      }

      // 6. Validar estado de conexi√≥n
      if (!bleDevice.isConnected) {
        throw Exception('Device disconnected unexpectedly after setup');
      }

      debugPrint('   ‚úÖ Temporary connection established successfully');
      debugPrint('   üìä Device state: connected=${bleDevice.isConnected}');

      return bleDevice;
    } on Exception catch (e) {
      debugPrint('   ‚ùå Temporary connection failed: $e');
      throw Exception(
        'Failed to establish temporary connection to $deviceId: $e',
      );
    }
  }

  /// Prepara un dispositivo con ciclo completo: conectar ‚Üí bond ‚Üí desconectar
  ///
  /// **Prop√≥sito:**
  /// - Establecer pairing/bonding con el dispositivo
  /// - Refrescar informaci√≥n del dispositivo
  /// - Dejarlo listo para reconexi√≥n posterior
  ///
  /// **Flujo:**
  /// 1. Conectar temporalmente
  /// 2. Realizar bonding/pairing
  /// 3. Descubrir servicios b√°sicos
  /// 4. Desconectar limpiamente
  /// 5. Retornar dispositivo preparado (desconectado pero bonded)
  ///
  /// **Par√°metros:**
  /// - [deviceId]: Direcci√≥n MAC del dispositivo
  /// - [timeout]: Tiempo m√°ximo para cada operaci√≥n
  ///
  /// **Retorna:**
  /// - [fbp.BluetoothDevice] preparado y bonded (desconectado)
  ///
  /// **Throws:**
  /// - [Exception] si alguna etapa del proceso falla
  Future<fbp.BluetoothDevice> prepareDeviceWithBonding({
    required final String deviceId,
    final Duration timeout = const Duration(seconds: 15),
  }) async {
    debugPrint(
      'üîß BleService: Preparing device $deviceId with bonding cycle...',
    );

    try {
      // 1. Obtener dispositivo fresco
      debugPrint('   üì° Getting fresh device instance...');
      final bleDevice = await getBluetoothDeviceAsync(deviceId);

      // 2. Conectar temporalmente
      debugPrint('   üîó Establishing temporary connection...');
      if (!bleDevice.isConnected) {
        await bleDevice.connect(
          mtu: 247,
          timeout: timeout,
          license: fbp.License.free,
        );
        debugPrint('   ‚úÖ Connected successfully');
      }

      // 3. Esperar estabilizaci√≥n
      await Future.delayed(const Duration(milliseconds: 500));

      // 4. Realizar bonding/pairing MEJORADO con CompanionDevice
      debugPrint(
        '   ü§ù Ensuring device is bonded with CompanionDevice support...',
      );

      // Verificar estado actual de bonding
      final bondState = await bleDevice.bondState.first;
      debugPrint('   Current bond state: $bondState');

      if (bondState == fbp.BluetoothBondState.bonded) {
        debugPrint('   ‚úÖ Device already bonded');
      } else {
        debugPrint('   ‚ö†Ô∏è Device not bonded, initiating bonding process...');

        // Crear bond tradicional primero
        debugPrint('   üîê Creating Bluetooth bond...');
        await bleDevice.createBond(timeout: 60);
        debugPrint('   ‚úÖ Bonding request completed');

        // Verificar resultado final
        final newBondState = await bleDevice.bondState.first;
        debugPrint('   üìä Final bond state: $newBondState');

        if (newBondState != fbp.BluetoothBondState.bonded) {
          throw Exception('Bonding failed - device not in bonded state');
        }
      }

      debugPrint('   ‚úÖ Device bonding and registration completed');

      // 5. Descubrir servicios b√°sicos para refrescar estado
      debugPrint('   üîç Discovering services for state refresh...');
      final services = await bleDevice.discoverServices();
      debugPrint('   üìã Discovered ${services.length} services');

      // 6. Leer informaci√≥n b√°sica
      try {
        final rssi = await bleDevice.readRssi();
        debugPrint('   üì∂ Final RSSI: $rssi dBm');
      } on Exception catch (e) {
        debugPrint('   ‚ö†Ô∏è Could not read final RSSI: $e');
      }

      // 7. DESCONECTAR limpiamente
      debugPrint('   üîå Disconnecting cleanly...');
      await bleDevice.disconnect();

      // 8. Esperar desconexi√≥n completa
      await Future.delayed(const Duration(milliseconds: 1000));

      debugPrint('   ‚úÖ Device preparation completed successfully');
      debugPrint(
        '   üìä Final state: connected=${bleDevice.isConnected}, bonded=true',
      );

      return bleDevice;
    } on Exception catch (e) {
      debugPrint('   ‚ùå Device preparation failed: $e');
      throw Exception('Failed to prepare device $deviceId: $e');
    }
  }
}
